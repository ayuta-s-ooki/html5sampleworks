<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>getComputedStyle</title>
<style>
.col {
  float: left;
  padding: 0 10px;
  margin: 0 5px;
}
#clearfix {
  clear: both;
}

.printer {
  font-style: italic;
  font-size: 11px;
}

#baseStyle {
  background-color: aqua;
}

#debug {
  background-color: pink;
}

#text:first-letter {
  font-size: 2em;
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
}
.box {
  width: 50px;
  height: 50px;
  margin: 5px;
  background-color: green;
  color: white;
}
</style>
</head>
<body>
<h1>getComputedStyleサンプル</h1>
<div id="container">
  <div id="content" class="col">
    <p id="text">テストサンプル</p>
    <div id="box1" class="box">box1</div>
  </div>
  <div id="baseStyle" class="col printer"></div>
  <div id="debug" class="col printer"></div>
  <div id="clearfix"></div>
</div>
<script>
(function() {
  /** @type {RegExp} CSSプロパティキーパターンマッチ */
  var namedArgRegExp = /%\((\w+)\)s/;

  /** @type {Array.<string>} Text CSSプロパティ用テンプレート配列 */
  var textTemplate = [
    '#text:first-letter {',
    '  font-size: %(fontSize)s;',
    '  background-color: %(backgroundColor)s;',
    '  color: %(color)s;',
    '}'
  ];

  /** @type {Array.<string>} Box CSSプロパティ用テンプレート配列 */
  var boxTemplate = [
    '.box {',
    '  width: %(width)s;',
    '  height: %(height)s;',
    '  margin: %(margin)s;',
    '  background-color: %(backgroundColor)s;',
    '  color: %(color)s;',
    '}'
  ];

  /**
   * <p>出力用文字列生成
   *
   * @param {string} string 内容.
   * @return pタグで囲まれた文字列.
   */
  function createParagraph(string) {
    var str = string.replace(/ /g, '&nbsp;');
    return ['<p>', str, '</p>'].join('');
  }

  /**
   * CSSプロパティ用文字列を構築し、バッファに追加
   *
   * @param {Array.<string>} buf 格納バッファ.
   * @param {Object} props CSSプロパティ.
   * @param {Array.<string>} template
   *    CSSプロパティ値プレースホルダー付き文字列テンプレート.
   * @param {RegExp} regex プレースホルダー取得用RegExp.
   */
  function buildCSSFragments(buf, props, template, regex) {
    /**
     * 正規表現最初の後方参照結果を返す
     *
     * @param {RegExp} regex プレースホルダー取得用RegExp.
     * @param {string} ソース文字列.
     * @return {?string} 一致した文字列 OR null.
     */
    function firstMatch(regex, string) {
      var match = string.match(regex);
      return match ? match[1] : null;
    }

    for (var i = 0; i < template.length; i++) {
      var prop = firstMatch(regex, template[i]);
      buf[buf.length] = createParagraph(template[i].replace(regex, props[prop]));
    }
  }

  // Entry point.
  window.addEventListener('load', function(e) {
    var baseStyle = document.getElementById('baseStyle'),
        debug = document.getElementById('debug'),
        text = document.getElementById('text'),
        box = document.getElementById('box1');

    var cssTextValues = {
      fontSize: '2em',
      backgroundColor: 'rgba(0, 0, 0, 0.8)',
      color: 'white'
    };
    var cssBoxValues = {
      width: '50px',
      height: '50px',
      margin: '5px',
      backgroundColor: 'green',
      color: 'white'
    };

    var buffer = [];
    buffer[buffer.length] = createParagraph('CSS:');
    buildCSSFragments(buffer, cssTextValues, textTemplate, namedArgRegExp);
    buildCSSFragments(buffer, cssBoxValues, boxTemplate, namedArgRegExp);

    baseStyle.innerHTML = buffer.join('');

    // textの算出済みスタイルを取得
    var textStyles = document.defaultView.getComputedStyle(text, ':first-letter');
    // boxの算出済みスタイルを取得
    var boxStyles = document.defaultView.getComputedStyle(box);

    // 算出済みスタイルはキャメルケースで取得できる(font-size -> fontSize)
    buffer = [];
    buffer[buffer.length] = createParagraph('Computed Style:');
    buildCSSFragments(buffer, textStyles, textTemplate, namedArgRegExp);
    buildCSSFragments(buffer, boxStyles, boxTemplate, namedArgRegExp);

    // 算出済みスタイルを画面に出力
    debug.innerHTML = buffer.join('');
  }, false);
}());
</script>
</body>
</html>
